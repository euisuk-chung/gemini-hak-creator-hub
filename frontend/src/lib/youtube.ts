import type { YouTubeComment } from './toxicity-types';

const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';

// ─── Types ─────────────────────────────────────────────────────────

export interface VideoDetail {
  videoId: string;
  title: string;
  channelTitle: string;
  channelId: string;
  description: string;
  thumbnailUrl: string;
  publishedAt: string;
  tags: string[];
  duration: string;          // ISO 8601 duration (PT4M13S)
  durationSeconds: number;
  viewCount: number;
  likeCount: number;
  commentCount: number;
  categoryId: string;
}

export interface CaptionInfo {
  id: string;
  language: string;
  name: string;
  isAutoGenerated: boolean;
}

// ─── URL Parsing ───────────────────────────────────────────────────

/** YouTube URL에서 videoId 추출 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/,
    /(?:youtu\.be\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  if (/^[a-zA-Z0-9_-]{11}$/.test(url.trim())) {
    return url.trim();
  }

  return null;
}

// ─── Video Info ────────────────────────────────────────────────────

/** ISO 8601 duration → seconds */
function parseDuration(iso: string): number {
  const match = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (!match) return 0;
  const h = parseInt(match[1] || '0');
  const m = parseInt(match[2] || '0');
  const s = parseInt(match[3] || '0');
  return h * 3600 + m * 60 + s;
}

/** 영상 기본 정보 조회 (간단 버전) */
export async function getVideoInfo(
  videoId: string,
  apiKey: string
): Promise<{ title: string; channelTitle: string; thumbnailUrl: string }> {
  const url = `${YOUTUBE_API_BASE}/videos?part=snippet&id=${videoId}&key=${apiKey}`;
  const res = await fetch(url);

  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.error?.message || 'YouTube API 호출에 실패했습니다.');
  }

  const data = await res.json();

  if (!data.items || data.items.length === 0) {
    throw new Error('영상을 찾을 수 없습니다.');
  }

  const snippet = data.items[0].snippet;
  return {
    title: snippet.title,
    channelTitle: snippet.channelTitle,
    thumbnailUrl: snippet.thumbnails?.medium?.url || snippet.thumbnails?.default?.url || '',
  };
}

/** 영상 상세 정보 조회 (확장 버전: snippet + contentDetails + statistics) */
export async function getVideoDetail(
  videoId: string,
  apiKey: string
): Promise<VideoDetail> {
  const url = `${YOUTUBE_API_BASE}/videos?part=snippet,contentDetails,statistics&id=${videoId}&key=${apiKey}`;
  const res = await fetch(url);

  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.error?.message || 'YouTube API 호출에 실패했습니다.');
  }

  const data = await res.json();

  if (!data.items || data.items.length === 0) {
    throw new Error('영상을 찾을 수 없습니다.');
  }

  const item = data.items[0];
  const { snippet, contentDetails, statistics } = item;

  return {
    videoId,
    title: snippet.title,
    channelTitle: snippet.channelTitle,
    channelId: snippet.channelId,
    description: snippet.description || '',
    thumbnailUrl: snippet.thumbnails?.maxres?.url || snippet.thumbnails?.high?.url || snippet.thumbnails?.medium?.url || '',
    publishedAt: snippet.publishedAt,
    tags: snippet.tags || [],
    duration: contentDetails.duration,
    durationSeconds: parseDuration(contentDetails.duration),
    viewCount: parseInt(statistics.viewCount || '0'),
    likeCount: parseInt(statistics.likeCount || '0'),
    commentCount: parseInt(statistics.commentCount || '0'),
    categoryId: snippet.categoryId || '',
  };
}

// ─── Comments ──────────────────────────────────────────────────────

/** 댓글 목록 조회 (페이지네이션 포함, 최대 maxResults개) */
export async function fetchComments(
  videoId: string,
  apiKey: string,
  maxResults: number = 100
): Promise<YouTubeComment[]> {
  const comments: YouTubeComment[] = [];
  let pageToken: string | undefined;

  while (comments.length < maxResults) {
    const perPage = Math.min(100, maxResults - comments.length);
    let url = `${YOUTUBE_API_BASE}/commentThreads?part=snippet&videoId=${videoId}&maxResults=${perPage}&order=relevance&textFormat=plainText&key=${apiKey}`;

    if (pageToken) {
      url += `&pageToken=${pageToken}`;
    }

    const res = await fetch(url);

    if (!res.ok) {
      const error = await res.json();
      const msg = error.error?.message || 'YouTube 댓글 조회에 실패했습니다.';

      if (error.error?.errors?.[0]?.reason === 'commentsDisabled') {
        throw new Error('이 영상은 댓글이 비활성화되어 있습니다.');
      }

      throw new Error(msg);
    }

    const data = await res.json();

    if (!data.items || data.items.length === 0) break;

    for (const item of data.items) {
      const snippet = item.snippet.topLevelComment.snippet;
      comments.push({
        commentId: item.snippet.topLevelComment.id,
        author: snippet.authorDisplayName,
        text: snippet.textDisplay,
        publishedAt: snippet.publishedAt,
        likeCount: snippet.likeCount || 0,
      });
    }

    pageToken = data.nextPageToken;
    if (!pageToken) break;
  }

  return comments;
}

// ─── Captions (YouTube Data API v3) ────────────────────────────────

/** 사용 가능한 자막 목록 조회 */
export async function listCaptions(
  videoId: string,
  apiKey: string
): Promise<CaptionInfo[]> {
  const url = `${YOUTUBE_API_BASE}/captions?part=snippet&videoId=${videoId}&key=${apiKey}`;
  const res = await fetch(url);

  if (!res.ok) {
    return [];
  }

  const data = await res.json();

  if (!data.items) return [];

  return data.items.map((item: any) => ({
    id: item.id,
    language: item.snippet.language,
    name: item.snippet.name || item.snippet.language,
    isAutoGenerated: item.snippet.trackKind === 'ASR',
  }));
}
